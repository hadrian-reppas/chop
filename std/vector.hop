import std::prelude

struct vector[T] {
    pointer: *T
    length: int
    capacity: int
}

fn new_vector[T] *T -> vector[T] {
    0 0 vector
}

fn push[T] *vector[T] T {
    swap ..length read swap ..capacity read rot
    if == {
        . std_realloc_vector
    }
    ..pointer read swap ..length read rot + rot write
    .length . read 1 + write
}

fn index[T] *vector[T] int -> T {
    let vec i {
        0 i <= assert
        i vec .length read < assert
        vec .pointer read i + read
    }
}

fn pop[T] *vector[T] -> T {
    ..length read 0 > assert
    ..length . read 1 - write
    ..length read swap .pointer read + read
}

fn free_vector[T] vector[T] {
    if ..capacity 0 > {
        .pointer free
    } else {
        ~
    }
}

fn std_realloc_vector[T] *vector[T] {
    if ..capacity read 0 == {
        ..capacity 10 write
        .pointer 10 alloc_arr[T] write
    } else {
        ..length read 2 * . rot ..capacity rot write
        ..pointer read rot realloc swap .pointer swap write
    }
}
