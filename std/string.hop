import struct std::vector::{Vector}
import std::vector::{.length .capacity}

struct String {
    bytes: Vector[byte]
}

fn new_string -> String {
    abort[String] // TODO
}

fn push *String int {
    if . 128 < {
        to_byte push_one
    } else if . 2048 < {
        two_bytes push_two
    } else if . 65536 < {
        three_bytes push_three
    } else {
        four_bytes push_four
    }
}

fn push *String *byte {
    ~ ~ abort
}

fn push_one *String byte {
    let s b {
        if s .bytes .length * 2 + s .capacity * >= {
            s grow_string
        }
        s .bytes * s .length * + b write
        s .bytes * s .length * + 1 + 0 to_byte write
        s .length . * 1 + write
    }
}

fn push_two *String byte byte {
    let s b1 b2 {
        if s .length * 3 + s .capacity * >= {
            s grow_string
        }
        s .bytes * s .length * + b1 write
        s .bytes * s .length * + 1 + b2 write
        s .bytes * s .length * + 2 + 0 to_byte write
        s .length . * 2 + write
    }
}

fn push_three *String byte byte byte {
    let s b1 b2 b3 {
        if s .length * 4 + s .capacity * >= {
            s grow_string
        }
        s .bytes * s .length * + b1 write
        s .bytes * s .length * + 1 + b2 write
        s .bytes * s .length * + 2 + b3 write
        s .bytes * s .length * + 3 + 0 to_byte write
        s .length . * 3 + write
    }
}

fn push_four *String byte byte byte byte {
    let s b1 b2 b3 b4 {
        if s .length * 5 + s .capacity * >= {
            s grow_string
        }
        s .bytes * s .length * + b1 write
        s .bytes * s .length * + 1 + b2 write
        s .bytes * s .length * + 2 + b3 write
        s .bytes * s .length * + 3 + b4 write
        s .bytes * s .length * + 4 + 0 to_byte write
        s .length . * 4 + write
    }
}

fn two_bytes int -> byte byte {
    let c {
        c 6 >> 31 & 192 | to_byte
        c 63 & 128 | to_byte
    }
}

fn three_bytes int -> byte byte byte {
    let c {
        c 12 >> 15 & 224 | to_byte
        c 6 >> 63 & 128 | to_byte
        c 63 & 128 | to_byte
    }
}

fn four_bytes int -> byte byte byte byte {
    let c {
        c 18 >> 7 & 240 | to_byte
        c 12 >> 63 & 128 | to_byte
        c 6 >> 63 & 128 | to_byte
        c 63 & 128 | to_byte
    }
}

fn grow_string *String {
    ..capacity *
    if . 0 == {
        ~
        .bytes 10 alloc_arr[byte] write
    } else {
        2 *
        let new_capacity {
            ..bytes * new_capacity realloc
            let new_bytes {
                ..bytes new_bytes write
            }
            .capacity new_capacity write
        }
    }
}

fn free_string String {
    .bytes free
}
